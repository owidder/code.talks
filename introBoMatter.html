<!DOCTYPE html>
<meta charset="utf-8">

<link rel="stylesheet" type="text/css" href="node_modules/materialize-css/dist/css/materialize.css" media="screen,projection"/>
<link rel="stylesheet" type="text/css" href="css/material-icons.css"/>
<link rel="stylesheet" type="text/css" href="css/legend.css">

<script src="node_modules/d3/build/d3.js"></script>
<script src="node_modules/lodash/lodash.js"></script>
<script src="node_modules/bottlejs/dist/bottle.js"></script>
<script>const bottle = new Bottle();</script>
<script src="node_modules/matter-js/build/matter.js"></script>
<script src="node_modules/jquery/dist/jquery.js"></script>
<script src="node_modules/js-url/url.js"></script>

<script src="js/util/util.js"></script>
<script src="js/util/svgUtil.js"></script>
<script src="js/util/SimplePromise.js"></script>
<script src="js/matterD3Renderer.js"></script>
<script src="js/legend.js"></script>
<script src="js/svg.js"></script>
<script src="js/bo.js"></script>
<script src="js/Engine.js"></script>

<style>

    #svgcanvas {
        position: absolute;
        top: 0;
        left: 0;
    }

    rect.bar, g.matter rect, .matter {
        opacity: .8;
        stroke: black;
        stroke-width: 2px;
    }

    text.bar, g.matter text {
        font-size: 2em;
        opacity: .5;
        font-weight: bolder;
    }

    text.dynamic {
        font-size: .75em;
    }

</style>
<body>
<div id="svgcanvas"></div>
<h1 id="title"></h1>
<a class="btn-floating btn-large waves-effect waves-light blue"onclick="bo.prev()" ><i class="material-icons">skip_previous</i></a>
<a class="btn-floating btn-large waves-effect waves-light blue"onclick="bo.next()" ><i class="material-icons">skip_next</i></a>

<script>

    /* global d3 */
    /* global _ */
    /* global bottle */

    const Svg = bottle.container.Svg;
    const Bo = bottle.container.Bo;
    const Engine = bottle.container.Engine;
    const util = bottle.container.util;

    const date = util.getHashParam("date", "");

    var width = window.innerWidth;
    var height = window.innerHeight;

    const g = (new Svg("#svgcanvas", width, height)).drawingG;

    var BAR_OFFSET_X = width/4;
    var BAR_OFFSET_Y = height/2;
    var BAR_WIDTH = 100 ;
    var BAR_GAP = 5;
    var START_HEIGHT = 0;

    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var _height = d3.scaleLinear().domain([0, 1e+8]).range([0, height/2]);

    function _x(index) {
        return index * (BAR_WIDTH + BAR_GAP) + BAR_OFFSET_X;
    }

    function textTranslate(x, y) {
        return "translate(" + x + "," + y + ") rotate(270)";
    }

    function legend(d) {
        return d.title + ": " + d3.format(",d")(d.wg);
    }

    function drawBars(data) {

        document.querySelector("h1#title").innerHTML = data[0].date;

        /////////////////////////////////
        // SELECT
        /////////////////////////////////

        const rectSelectionWithData = g.selectAll("rect.bar")
            .data(data, function (d) {
                return d.title;
            });

        const textSelectionWithData = g.selectAll("text.bar")
            .data(data, function (d) {
                return d.title;
            });

        /////////////////////////////////
        // ENTER
        /////////////////////////////////

        // rect
        rectSelectionWithData.enter()
            .append("rect")
            .attr("class", "bar forlegend")
            .attr("width", BAR_WIDTH)
            .style("fill", function (d) {
                return color(d.title);
            })
            .attr("x", function (d) {
                return _x(d.i);
            })
            .attr("height", START_HEIGHT)
            .attr("y", BAR_OFFSET_Y - START_HEIGHT);

        // text
        const textEnter = textSelectionWithData.enter()
            .append("text")
            .attr("class", "bar")
            .text(function (d) {
                return d.title;
            })
            .attr("transform", function (d) {
                var x = _x(d.i) + BAR_WIDTH/2;
                return textTranslate(x, BAR_OFFSET_Y - 10);
            });

        /////////////////////////////////
        // UPDATE
        /////////////////////////////////

        // rect
        d3.selectAll("rect.bar")
            .transition()
            .duration(1000)
            .attr("x", function (d) {
                const x = _x(d.i);
                d.x = x;
                return x;
            })
            .attr("_legend", legend)
            .attr("height", function(d) {
                const height = _height(d.wg);
                d.height = height;
                return height;
            })
            .attr("y", function (d) {
                const y = BAR_OFFSET_Y - _height(d.wg);
                d.y = y;
                return y;
            });

        // text
        d3.selectAll("text.bar")
            .transition()
            .duration(1000)
            .attr("transform", function (d) {
                var x = _x(d.i) + BAR_WIDTH/2;
                return textTranslate(x, BAR_OFFSET_Y - 10);
            });

        /////////////////////////////////
        // EXIT
        /////////////////////////////////

        rectSelectionWithData.exit()
            .each(function (d) {
                const x = _x(d.i);
                const bodyX = x + BAR_WIDTH/2;
                const bodyY = BAR_OFFSET_Y - _height(d.wg) + d.height/2;

                const rectBody = Matter.Bodies.rectangle(bodyX, bodyY, BAR_WIDTH, d.height, {
                    isStatic: false, __data: d, color: color(d.title), className: "matter forlegend",
                    _legend: legend(d), title: d.title
                });

                const circleBody = Matter.Bodies.circle(x + (BAR_WIDTH*Math.random()), BAR_OFFSET_Y + 100, 2, {
                    isStatic: true, color: "grey", className: "matter"
                });

                Matter.World.add(engine.world, [rectBody, circleBody]);

                setTimeout(function () {
                    Matter.World.remove(engine.world, circleBody);
                }, 3000);

                setTimeout(function () {
                    Matter.World.remove(engine.world, rectBody);
                }, 20000)
            })
            .remove();

        textSelectionWithData.exit().remove();
    }

    const engine = new Engine();

    function addBottom() {
        var rect = Matter.Bodies.rectangle(width/2, height, width, 100, {
            isStatic: true, color: "grey", className: "matter"
        });

        Matter.World.add(engine.world, [rect]);
    }

    function createPathFromBody(d) {
        var pathStr = "";
        if(d.vertices.length > 0) {
            pathStr += "M" + d.vertices[0].x + " " + d.vertices[0].y;
            if(d.vertices.length > 1) {
                var i;
                for(i = 1; i < d.vertices.length; i++) {
                    pathStr += " L" + d.vertices[i].x + " " + d.vertices[i].y;
                }
            }
        }
        pathStr += " Z";

        return pathStr;
    }

    function drawMatter2() {
        var dynamic = Matter.Composite.allBodies(engine.world).filter(function (b) {
            return (b.isStatic == false);
        });

        var data = g.selectAll("path.dynamic")
            .data(dynamic, function(d) {
                return d.id;
            });

        data.enter()
            .append("path")
            .attr("class", "dynamic")
            .style("fill", function (d) {
                return color(d.__data.title);
            });

        g.selectAll("path.dynamic")
            .attr("d", createPathFromBody);

        data.exit().remove();
    }

    function drawMatter() {
        const dynamicBodies = Matter.Composite.allBodies(engine.world).filter(function (b) {
            return (b.isStatic == false);
        });

        const selectData = g.selectAll("g.matter").data(dynamicBodies, function(d) {
            return d.id;
        });

        const enterG = selectData.enter()
            .append("g")
            .attr("class", "matter");

        enterG.append("rect")
            .attr("width", BAR_WIDTH)
            .attr("height", function(d) {
                return d.__data.height;
            })
            .style("fill", function (d) {
                return color(d.__data.title);
            });

        enterG.append("text")
            .text(function (d) {
                return d.__data.title;
            })
            .attr("transform", function (d) {
                var x = BAR_WIDTH/2;
                return textTranslate(x, -10);
            });


        g.selectAll("g.matter")
            .attr("transform", function (d) {
                const cOffsetX = BAR_WIDTH/2;
                const cOffsetY = d.__data.height/2;
                const x = d.position.x - cOffsetX;
                const y = d.position.y - cOffsetY;
                return "translate(" + x + "," + y + ") rotate(" + (d.angle / 2*Math.PI * 360) + "," + cOffsetX + "," + cOffsetY + ")";
            });

        selectData.exit().remove();
    }

    const bo = new Bo(drawBars, 5);
    bo.ready.then(function () {
        if(_.isEmpty(date)) {
            bo.next();
        }
        else {
            bo.goto(date);
        }

        var d3Renderer = new MatterD3Renderer(engine, g, width, height);
        engine.start(d3Renderer.renderD3);
        engine.world.gravity.x = 0;
        engine.world.gravity.y = 0.3;
        addBottom();
    });

</script>
</body>
</html>
